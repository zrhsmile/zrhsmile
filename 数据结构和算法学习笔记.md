# 第一章：概念

## 数据结构和算法的概念

​	从广义上讲，**数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法**。图书馆储藏书籍你肯定见过吧？为了方便查找，图书管理员一般会将书籍分门别类进行“存储”。**按照一定规律编号，就是书籍这种“数据”的存储结构**。那我们如何来查找一本书呢？有很多种办法，你当然可以一本一本地找，也可以先根据书籍类别的编号，是人文，还是科学、计算机，来定位书架，然后再依次查找。笼统地说，这些查找方法都是**算法。**

## 数据结构与算法的关系

​	**数据结构和算法是相辅相成的。数据结构是为算法服务的，算法要作用在特定的数据结构之上**。 因此，我们无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构。

​	比如，因为数组具有随机访问的特点，常用的二分查找算法需要用数组来存储数据。但如果我们选择链表这种数据结构，二分查找算法就无法工作了，因为链表并不支持随机访问。

## 时间复杂度和空间复杂度概念

​	首先要掌握一个数据结构与算法中最重要的概念——复杂度分析。**它几乎占了数据结构和算法这门课的半壁江山，是数据结构和算法学习的精髓**。

​	数据结构和算法解决的是如何更省、更快地存储和处理数据的问题，因此，我们就需要一个考量效率和资源消耗的方法，这就是复杂度分析方法

## 数据结构与算法概览图

![img](https://static001.geekbang.org/resource/image/91/a7/913e0ababe43a2d57267df5c5f0832a7.jpg)

## 十大常见的数据结构

### 	数组、	链表、堆、栈、图、二叉树、队列、跳表、散列表、Trie 树；

## 十大常见的算法

### 	递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法

# 第二章 ：时间复杂度和空间复杂度

## 	复杂度的概念	

​		复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。

## 	为什么需要复杂度分析

​		我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法

## 	大O复杂度表示法

~~~java
 int cal(int n) {
   int sum = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1;
     for (; j <= n; ++j) {//执行了n²次
       sum = sum +  i * j;//执行了n²次
     }
   }
 }
~~~

总时间是：整段代码总的执行时间 T(n) = (2n²+2n+3)*unit_time。

所有代码的执行时间 T(n) 与每行代码的执行次数 f(n) 成正比。

总结成公式是：

![img](https://static001.geekbang.org/resource/image/22/ef/22900968aa2b190072c985a08b0e92ef.png)

其中，T(n) 它表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。

**用大O表示，就是：T(n) = O(2n²+2n+3)  这个就是大O时间复杂度表示法。**

**大 O 时间复杂度表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。** 

公式中的低阶、常量、系数三部分并不左右增长趋势，因此都可以忽略。

最终，公式可以简化成： T(n) = O(n²)

## 时间复杂度规则

1. **只关注循环执行次数最多的一段代码**

   我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了

2. **加法法则：总复杂度等于量级最大的那段代码的复杂度**

3. **乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积**

## 复杂度量级

​	![img](https://static001.geekbang.org/resource/image/37/0a/3723793cc5c810e9d5b06bc95325bf0a.jpg)

### 	非多项式量级

​		O(2ⁿ) 和 O(n!)。

### 	多项式量级

1. O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）

2. O(1)

   代码的执行时间不随 n 的增大而增长；一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。

3. O(logn)、O(nlogn)

   ![image-20211223020943075](C:\Users\zrhsmile\AppData\Roaming\Typora\typora-user-images\image-20211223020943075.png)

   **在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))** 即： O(logn)

   

   **如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了** ；比如算法：归并排序、快速排序的时间复杂度都是 O(nlogn)。

4. O(m+n)、O(m*n)【代码的复杂度由两个数据的规模来决定】

   ~~~c++
   int cal(int m, int n) {
     int sum_1 = 0;
     int i = 1;
     for (; i < m; ++i) {
       sum_1 = sum_1 + i;
     }
   
     int sum_2 = 0;
     int j = 1;
     for (; j < n; ++j) {
       sum_2 = sum_2 + j;
     }
   
     return sum_1 + sum_2;
   }
   ~~~

   从代码中可以看出，m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。	

## 空间复杂度分析

### 	概念

​	空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。

### 	实例

~~~c++

void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i <n; ++i) {
    a[i] = i * i;
  }

  for (i = n-1; i >= 0; --i) {
    print out a[i]
  }
}
~~~

跟时间复杂度分析一样，我们可以看到，第 2 行代码中，我们申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。

## 小结

**分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )。**

![img](https://static001.geekbang.org/resource/image/49/04/497a3f120b7debee07dc0d03984faf04.jpg)

